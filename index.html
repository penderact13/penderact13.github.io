<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cube Texture OBJ Generator</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 40px;
      background: #202020;
      color: white;
    }
    canvas {
      display: block;
      margin: 20px auto;
      border: 1px solid #444;
    }
    input, button {
      margin: 10px;
      padding: 10px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <h1>Cube Texture OBJ Generator</h1>
  <input type="file" id="textureInput" accept="image/bmp,image/png,image/jpeg" />
  <br />
  <button id="exportBtn" disabled>Download OBJ</button>
  <canvas id="preview" width="400" height="400"></canvas>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';
    import { OBJExporter } from 'https://esm.sh/three/examples/jsm/exporters/OBJExporter.js';

    const input = document.getElementById('textureInput');
    const button = document.getElementById('exportBtn');
    const canvas = document.getElementById('preview');

    let texture, mesh;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 100);
    camera.position.z = 2;
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(400, 400);
    renderer.setClearColor(0x111111);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(2, 2, 2);
    scene.add(light);

    const animate = () => {
      requestAnimationFrame(animate);
      if (mesh) mesh.rotation.y += 0.01;
      renderer.render(scene, camera);
    };

    input.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      console.log("üìÇ File selected:", file.name);

      const bitmap = await createImageBitmap(file).catch(err => {
        console.error("‚ùå Failed to decode image:", err);
        alert("Could not decode image. Try PNG or JPEG.");
      });
      if (!bitmap) return;

      const canvasImg = document.createElement('canvas');
      canvasImg.width = bitmap.width;
      canvasImg.height = bitmap.height;
      const ctx = canvasImg.getContext('2d');
      ctx.drawImage(bitmap, 0, 0);
      const tex = new THREE.Texture(canvasImg);
      tex.needsUpdate = true;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;

      if (mesh) scene.remove(mesh);
      texture = tex;

      const geo = new THREE.BoxGeometry(1, 1, 1);
      const uvs = geo.attributes.uv.array;

      const tiles = {
        top:    [0/3, 0/2, 1/3, 1/2],
        bottom: [1/3, 1/2, 2/3, 1],
        left:   [0/3, 1/2, 1/3, 1],
        right:  [2/3, 0/2, 1, 1/2],
        front:  [1/3, 0,
